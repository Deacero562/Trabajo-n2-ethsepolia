// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.2 <0.9.0;

/// @title Subasta descentralizada con reembolsos parciales y extensiones de tiempo.
/// @author Sergio Gallo
/// @notice Contrato inteligente para manejar subastas con requisitos de validez, depÃ³sitos, y reembolsos.

contract Subasta {
    address public owner;
    address public pagoDestino;
    address public highestBidder;
    uint public highestBid;
    uint public auctionEndTime;
    uint public commissionPercentage = 2;
    bool public ended;

    struct Oferta {
        address oferente;
        uint monto;
    }

    Oferta[] public ofertas;
    mapping(address => uint) public deposits;

    event NuevaOferta(address indexed oferente, uint monto);
    event SubastaFinalizada(address ganador, uint monto);

    modifier soloPropietario() {
        require(msg.sender == owner, "Solo el propietario puede ejecutar esta funcion");
        _;
    }

    modifier subastaActiva() {
        require(block.timestamp < auctionEndTime, "La subasta ha finalizado");
        _;
    }

    constructor(uint _duracion, uint _precioInicial, address _pagoDestino, bool evitarContratos) {
        require(_pagoDestino != address(0), "Direccion invalida");
        if (evitarContratos) {
            require(!_esContrato(_pagoDestino), "No se permiten contratos como destino");
        }

        owner = msg.sender;
        pagoDestino = _pagoDestino;
        highestBid = _precioInicial;
        auctionEndTime = block.timestamp + _duracion;
    }

    function ofertar() external payable subastaActiva {
        require(msg.value > highestBid * 105 / 100, "La oferta debe superar en al menos 5% la oferta actual");

        if (highestBidder != address(0)) {
            deposits[highestBidder] += highestBid;
        }

        highestBidder = msg.sender;
        highestBid = msg.value;
        ofertas.push(Oferta(msg.sender, msg.value));

        emit NuevaOferta(msg.sender, msg.value);
    }

    function mostrarGanador() external view returns (address, uint) {
        require(ended, "La subasta aun no ha finalizado");
        return (highestBidder, highestBid);
    }

    function mostrarOfertas() external view returns (Oferta[] memory) {
        return ofertas;
    }

    function finalizarSubasta() external soloPropietario {
        require(block.timestamp >= auctionEndTime, "La subasta aun esta activa");
        require(!ended, "La subasta ya ha finalizado");

        ended = true;
        uint comision = highestBid * commissionPercentage / 100;
        uint neto = highestBid - comision;

        payable(pagoDestino).transfer(neto);

        emit SubastaFinalizada(highestBidder, highestBid);
    }

    function retirarDeposito() external {
        uint monto = deposits[msg.sender];
        require(monto > 0, "No hay fondos disponibles para retirar");

        deposits[msg.sender] = 0;
        payable(msg.sender).transfer(monto);
    }

    function _esContrato(address _addr) internal view returns (bool) {
        uint size;
        assembly {
            size := extcodesize(_addr)
        }
        return size > 0;
    }
}
