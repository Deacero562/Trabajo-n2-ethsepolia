// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.2 <0.9.0;

/// @title Subasta descentralizada con reembolsos parciales y extensiones de tiempo.
/// @author Sergio Gallo
/// @notice Contrato inteligente para manejar subastas con requisitos de validez, depósitos, y reembolsos.

contract Subasta {
    mapping(address => uint256) public bidsList;
    mapping(address => uint256) public bidsAmount;

    uint256 public startTime;
    uint256 public endTime;
    uint256 public bidHighestBid;

    bool public isActive;

    address public bidOwner;
    address public bidHighestBidder;

    address[] public bidBidders;

    modifier onlyOwner() {
        require(msg.sender == bidOwner, "You are not the bid owner");
        _;
    }

    modifier isAuctionActive() {
        require(isActive, "The auction is not active");
        _;
    }

    modifier isAuctionFinished() {
        require(!isActive, "The auction is active");
        _;
    }

    constructor(uint256 bidTime) {
        isActive = true;
        startTime = block.timestamp;
        endTime = block.timestamp + bidTime;
        bidOwner = msg.sender;
        bidHighestBid = 0;
    }

    function sendBid() external payable isAuctionActive {
        require(endTime > block.timestamp, "The auction is finished");
        require(msg.value > bidHighestBid * 105 / 100, "Your bid must be 5% higher than the highest bid");

        if (msg.value > bidHighestBid) {
            bidHighestBid = msg.value;
            bidHighestBidder = msg.sender;
        }

        // Si es la primera oferta del ofertante, se añade a la lista
        if (bidsList[msg.sender] == 0) {
            bidBidders.push(msg.sender);
        }

        bidsList[msg.sender] = msg.value;
        bidsAmount[msg.sender] += msg.value;

        emit NewBid(msg.sender, msg.value);

        // Extiende la subasta si quedan menos de 10 minutos
        if (endTime <= block.timestamp + 10 minutes) {
            endTime = block.timestamp + 10 minutes;
        }
    }

    function getWinner() external view isAuctionFinished returns (address) {
        return bidHighestBidder;
    }

    function getBids() external view returns (address[] memory, uint256[] memory) {
        uint256 biddersCount = bidBidders.length;
        uint256[] memory bidAmounts = new uint256[](biddersCount);
        address[] memory bidders = new address[](biddersCount);

        for (uint256 i = 0; i < biddersCount; i++) {
            bidders[i] = bidBidders[i];
            bidAmounts[i] = bidsAmount[bidBidders[i]];
        }
        return (bidders, bidAmounts);
    }

    function getHighestBid() external view returns (uint256) {
        return bidHighestBid;
    }

    // Función para que el propietario retire el saldo final de la subasta
    function withdrawBalance() external onlyOwner isAuctionFinished {
        uint256 balance = address(this).balance;
        require(balance > 0, "No funds to withdraw");
        payable(bidOwner).transfer(balance);
    }

    // Devuelve depósitos a todos los ofertantes que no ganaron, descontando 2% de comisión
    function returnBids() internal isAuctionFinished {
        uint256 biddersCount = bidBidders.length;

        for (uint256 i = 0; i < biddersCount; i++) {
            address bidder = bidBidders[i];
            uint256 amount = bidsAmount[bidder];

            if (bidder != bidHighestBidder && amount > 0) {
                payable(bidder).transfer(amount * 98 / 100);
                bidsAmount[bidder] = 0;
            }
        }
    }

    // Finaliza la subasta, emite evento, y devuelve depósitos
    function finishAuction() external onlyOwner isAuctionActive {
        isActive = false;

        emit AuctionFinished(bidHighestBidder, bidHighestBid);

        returnBids();
    }

    // Permite a un ofertante retirar el excedente de su depósito (dinero que no es la última oferta)
    function withdrawDeposit() external isAuctionFinished {
        uint256 amount = bidsAmount[msg.sender] - bidsList[msg.sender];
        require(amount > 0, "No excess to withdraw");
        bidsAmount[msg.sender] = bidsList[msg.sender];
        payable(msg.sender).transfer(amount);
    }

    // Eventos
    event NewBid(address indexed bidder, uint256 amount);
    event AuctionFinished(address indexed winner, uint256 amount);
}
