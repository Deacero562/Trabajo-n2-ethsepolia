// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.2 <0.9.0;

/// @title Subasta descentralizada con reembolsos parciales y extensiones de tiempo.
/// @author Sergio Gallo
/// @notice Contrato inteligente para manejar subastas con requisitos de validez, depósitos, y reembolsos.

contract Subasta {
    // Mapeos de depósitos, historial y última oferta
    mapping(address => uint256) public deposits;
    mapping(address => uint256[]) public bidHistory;
    mapping(address => bool) public isBidder;

    // Parámetros de tiempo y ofertas
    uint256 public startTime;
    uint256 public duration;
    uint256 public endTime;
    uint256 public startingBid;
    uint256 public highestBid;

    // Estado y seguridad
    bool public isActive;
    bool private locked;
    bool public isCancelled;

    // Roles y participantes
    address public owner;
    address public highestBidder;
    address[] public bidders;

    // Modificadores
    modifier onlyOwner() {
        require(msg.sender == owner, "No eres el propietario");
        _;
    }

    modifier noOwner() {
        require(msg.sender != owner, "El propietario no puede ofertar");
        _;
    }

    modifier auctionActive() {
        require(isActive && !isCancelled, "Subasta no activa");
        require(block.timestamp >= startTime, "Subasta aun no ha iniciado");
        require(block.timestamp < endTime, "Subasta finalizada");
        _;
    }

    modifier auctionFinished() {
        require(!isActive, "Subasta aun activa");
        _;
    }

    modifier noReentrancy() {
        require(!locked, "No reentrancia");
        locked = true;
        _;
        locked = false;
    }

    // Eventos
    event NewBid(address indexed bidder, uint256 amount);
    event AuctionFinished(address indexed winner, uint256 amount);
    event AuctionCancelled();
    event DepositWithdrawn(address indexed bidder, uint256 amount);

    constructor(uint256 _startTime, uint256 _duration, uint256 _startingBid) {
        require(_startTime >= block.timestamp, "Fecha de inicio invalida");
        require(_duration > 0, "Duracion debe ser mayor a cero");
        require(_startingBid > 0, "Oferta minima debe ser mayor a cero");

        owner = msg.sender;
        startTime = _startTime;
        duration = _duration;
        endTime = startTime + duration;
        startingBid = _startingBid;
        highestBid = _startingBid;
        isActive = true;
    }

    function sendBid() external payable auctionActive noReentrancy noOwner {
        require(msg.value > highestBid * 105 / 100, "Oferta debe superar en 5% a la mejor");

        if (highestBidder != address(0)) {
            deposits[highestBidder] += highestBid;
        }

        highestBid = msg.value;
        highestBidder = msg.sender;

        // Historial de pujas y listado de participantes
        bidHistory[msg.sender].push(msg.value);

        if (!isBidder[msg.sender]) {
            isBidder[msg.sender] = true;
            bidders.push(msg.sender);
        }

        deposits[msg.sender] += msg.value;

        if (endTime <= block.timestamp + 10 minutes) {
            endTime = block.timestamp + 10 minutes;
        }

        emit NewBid(msg.sender, msg.value);
    }

    function withdrawDeposit() external noReentrancy {
        uint256 deposit = deposits[msg.sender];
        require(deposit > 0, "No tienes deposito para retirar");

        // Calcular reembolso parcial si aún activa
        if (isActive && !isCancelled && msg.sender != highestBidder) {
            uint256 lastBid = bidHistory[msg.sender].length > 0 ? bidHistory[msg.sender][bidHistory[msg.sender].length - 1] : 0;
            if (deposit > lastBid) {
                uint256 excess = deposit - lastBid;
                deposits[msg.sender] = lastBid;
                uint256 refund = excess * 98 / 100; // Aplica comisión
                payable(msg.sender).transfer(refund);
                emit DepositWithdrawn(msg.sender, refund);
                return;
            }
        }

        // Si la subasta ya terminó o no hay exceso
        deposits[msg.sender] = 0;
        uint256 refundFinal = deposit * 98 / 100; // Aplica comisión
        payable(msg.sender).transfer(refundFinal);
        emit DepositWithdrawn(msg.sender, refundFinal);
    }

    function finishAuction() external onlyOwner auctionActive noReentrancy {
        require(block.timestamp >= endTime, "Subasta aun activa");
        isActive = false;
        emit AuctionFinished(highestBidder, highestBid);
    }

    function cancelAuction() external onlyOwner auctionActive noReentrancy {
        require(highestBidder == address(0), "No se puede cancelar tras la primera puja");
        isActive = false;
        isCancelled = true;
        emit AuctionCancelled();
    }

    function withdrawBalance() external onlyOwner auctionFinished noReentrancy {
        require(!isCancelled, "Subasta cancelada");
        uint256 balance = address(this).balance;
        uint256 totalDeposits;
        for (uint256 i = 0; i < bidders.length; i++) {
            totalDeposits += deposits[bidders[i]];
        }
        uint256 toWithdraw = balance - totalDeposits;
        require(toWithdraw > 0, "No hay fondos para retirar");
        payable(owner).transfer(toWithdraw);
    }

    function getWinner() external view auctionFinished returns (address) {
        require(!isCancelled, "Subasta cancelada");
        return highestBidder;
    }

    function getBidders() external view returns (address[] memory) {
        return bidders;
    }

    function getHighestBid() external view returns (uint256) {
        return highestBid;
    }

    function getBidHistory(address user) external view returns (uint256[] memory) {
        return bidHistory[user];
    }
} 
